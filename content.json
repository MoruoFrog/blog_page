{"meta":{"title":"Moruo's Blog","subtitle":"hello world","description":"Moruo的博客&&笔记","author":"Mor","url":"moruo.vip","root":"/"},"pages":[{"title":"About","date":"2018-06-09T12:24:09.000Z","updated":"2020-01-06T07:54:49.485Z","comments":true,"path":"about/index.html","permalink":"moruo.vip/about/index.html","excerpt":"","text":"体验数据在代码当中的流转体验身体在世界各地的旅行体验心智在时间长河中成长 Hello World"}],"posts":[{"title":"2020年度挑战计划","slug":"2020年计划","date":"2020-01-01T02:29:00.000Z","updated":"2020-01-06T08:02:39.495Z","comments":true,"path":"2020/01/01/2020年计划/","link":"","permalink":"moruo.vip/2020/01/01/2020年计划/","excerpt":"facebook的创始人扎克伯格从2009年开始，每年都会公布自己的年度挑战计划，他把这个计划称之为personal challenge。我决定效仿他，从今年开始，每年也制定一个年度挑战计划。","text":"facebook的创始人扎克伯格从2009年开始，每年都会公布自己的年度挑战计划，他把这个计划称之为personal challenge。我决定效仿他，从今年开始，每年也制定一个年度挑战计划。 扎克伯格的历年挑战 2009：每天打领带上班 2010：学中文 2011：只吃自己亲手屠宰的动物 2012：每天写代码 2013：每天认识一个facebook以外的朋友 2014：每天写一封经过谨慎思考后的感谢信 2015：每两周读一本书 2016：跑365公里，制作一个家庭AI助手 2017：到美国的每一个州 2018：”修整”facebook 2019：主持一系列关于社会技术未来的公开讨论，包括机遇、挑战、希望和焦虑 到目前为止，扎克伯格的年度挑战都成功完成。 2017年以前的挑战都非常的具体、可量化，而且真的是一个“挑战”。2018年以后，也许随着年岁增长，角色转变，看世界的视角提高，他的年度挑战变得更加宏大。 我的2020年度挑战计划其实以前也会制定一些年度计划之类的东西，但是最终能够完成的很少，比如至今未读完的《SICP》，比如刷了不到50道题的leetcode，比如没去过几次的健身房。也许因为计划太多，想要的太多，反而完成的很少。 所以，以后的年度计划只做一件事情，需要目标明确，可以量化。 那么，就从锻炼身体开始吧 – 2020年度计划，每周至少进行2次跑步，每次不低于2公里。 千里之行，始于足下。我的年度挑战，也从脚下开始。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"生活","slug":"生活","permalink":"moruo.vip/tags/生活/"},{"name":"年度挑战","slug":"年度挑战","permalink":"moruo.vip/tags/年度挑战/"}]},{"title":"生产环境部署es6代码","slug":"部署es6代码","date":"2019-11-07T15:28:00.000Z","updated":"2020-01-06T07:54:49.485Z","comments":true,"path":"2019/11/07/部署es6代码/","link":"","permalink":"moruo.vip/2019/11/07/部署es6代码/","excerpt":"时间流转，来到了9102年的末尾，距离es6正式发布已经过去了4年半。在前端发展的时间长河中，我们送别了YUI，ie（也许），jQuery，现在，是时候送别es5了。","text":"时间流转，来到了9102年的末尾，距离es6正式发布已经过去了4年半。在前端发展的时间长河中，我们送别了YUI，ie（也许），jQuery，现在，是时候送别es5了。 收益在哪程序员在进行技术决策的时候，通常的目的是为了kpi，升值加薪，这个技术很流行，不，当然是为了对业务产生价值。 不难发现，直接部署es6代码可以带来的好处包括： 代码体积减小 性能提升 缩短构建时间 代码体积减小首先，es6带来了新的语法和特性，这可以让代码更简洁，使得代码量减少。其次，babel转译之后，会产生一些helper，引入一些polyfill，而且有一些语法特性无法在运行时进行处理，必须在转译过程中修改源代码，这也会导致代码量增加。当然，部署es6代码也需要babel转译一部分更新的语法，并不是说完全不使用babel。 一个Google工程师的试验结果，es6代码的bundle size比es5代码减少了50%。而我自己的实践的结果没有这么夸张，是25%左右。 version bundle size Gzipped es5 221kb 39kb es6 170kb 29kb 之所以我和他的测试结果差异较大，是因为最终的结果跟每个人的代码风格和代码内容有很大的关系。我用来进行测试的代码是一个线上项目的代码，我个人的代码风格是大量使用es6/7/8语法，不过项目本身大量是在写业务逻辑，并且项目使用了Vue，其实很多js代码是模板编译之后生成的渲染函数。 所以，大概的结论是es6的代码会比es5的代码体积减少15% ~ 50%，具体能减少多少，取决于代码风格以及代码内容。代码风格越现代，代码中”生成的代码”越少，收益越高。 性能提升es6代码相对于es5代码，性能更高的原因我认为有2个 代码量减少带来的解析时间减少，这个正比于代码体积的减少 运行性能的提高 对于第一点，浏览器解析代码时间的减少应该占比较小，通过chrome的Performance面板可以看到，解析一个200kb的js文件Compile Script耗时为10ms（测试机器为台式机，i7/16G）。 对于第二点，运行时性能。在es6刚刚发布的时候，很多新特性的性能是比较低的，因为js引擎没有足够的时间去进行优化，相比较而言，es5以及更老的代码经过了浏览器的长时间优化，在es6刚出来的时候，很对人也对es6的性能有很大的担忧。 Github上有一个仓库，专门对es6和es5进行了性能对比。 从对比结果可以看出来，在chrome 72版本上，es6代码的性能优于babel转译成的es5代码，和手写的es5代码比起来各有千秋，基本算是55开。 而且，浏览器对于es6的性能优化是持续性的，最近V8就会因为React hooks而改进数组解构的性能。 针对运行时的es6代码和es5代码的性能对比，我也用一个线上项目进行了实验。实验方式如下 利用performance API 在打包后的app.js文件开头记下时间戳，在js文件末尾减去开始的时间，得到一个时间，众所周知，打包之后的app.js是一个立即执行函数，所以这个时间包含了app.js文件中部分代码的运行时间 利用chrome 的 Performance面板，可以直接得到一段js的执行时间Evaluate Script 实验结果如下（20次的平均值） version 记录的运行时间 Performance面板的Evaluate Script es5 258.88ms 295.29ms es6 206.28ms 241.59ms 测试条件下，es6的代码取得了20%左右的运行性能提升 风险在哪儿js的运行环境非常复杂，桌面端、移动端、各种小程序、各种webview、node.js，能否部署es6代码只能依靠自己判断。 就我个人的经验而言，大部分的中后台项目都具备直接部署es6代码的条件，而且我们在具体的实施中肯定会有降级方案，让不支持es6的情况下运行es5的代码。 如何实施Vue用户可以通过Vue cli的 –modern直接开启现代模式 非Vue使用者，可以通过这篇文章提到的方案来进行。大概就是利用script标签的module type作为浏览器是否全面支持es6的检测，并通过type=nomodule来进行降级处理。 12345// 不支持module的浏览器，下载但不会执行&lt;script type=\"module\" src=\"es6.js\"&gt;&lt;/script&gt;// 支持module的浏览器，不会下载&lt;script nomodule src=\"es5.js\"&gt;&lt;/script&gt; 一个需要注意的点是safari 10不支持nomodule，所以需要针对它解决重复下载并执行的问题。(ps: safari浏览器是新时代的毒瘤) 虽然，一个降级的方案可以保证我们的代码可以在只支持es5的浏览器上也可以执行，但是同时这些老的浏览器会下载2份代码，带来的损失非常大，因为老设备通常也意味着低性能和低网速，它们更不能承受性能损失。所以我认为，如果你的业务需要兼容es5的用户达到了20%以上，我就不赞同采用这个方案。 如果可以确定完全不需要兼容es5的用户，可以直接修改browserlist到全面支持es6的浏览器版本，并且不用考虑降级方案，此时还会带来构建速度提升这一额外的好处。 browserslist示例 12345Chrome &gt;= 60Safari &gt;= 10.1iOS &gt;= 10.3Firefox &gt;= 54Edge &gt;= 15 结语时间带走一切，es5也不例外。 参考 deploying-es2015-code-in-production-today https://myst729.github.io/posts/2018/deploying-es6-in-production/","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"moruo.vip/tags/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"moruo.vip/tags/性能优化/"}]},{"title":"大数据量场景下的Vue性能优化","slug":"大数据量场景下的Vue性能优化","date":"2019-09-18T12:10:00.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2019/09/18/大数据量场景下的Vue性能优化/","link":"","permalink":"moruo.vip/2019/09/18/大数据量场景下的Vue性能优化/","excerpt":"性能优化最常见的落脚点是在网络和dom上，但是在大数据量的场景下，由于Vue本身的特性，可能会造成js运行层面的性能问题，这篇文章讨论的就是针对这一部分的性能优化方案。 最终的结果会将一个2s的耗时减少到10ms","text":"性能优化最常见的落脚点是在网络和dom上，但是在大数据量的场景下，由于Vue本身的特性，可能会造成js运行层面的性能问题，这篇文章讨论的就是针对这一部分的性能优化方案。 最终的结果会将一个2s的耗时减少到10ms 模拟一个大数据量的场景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// App.vue&lt;template&gt; &lt;div&gt; &lt;p&gt;It's &#123;&#123; firstUser.name &#125;&#125;'s show time&lt;/p&gt; &lt;div&gt;total: &#123;&#123; total &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const user = []let i = 0while (i++ &lt; 50000) &#123; user.push(&#123; id: i, age: 18, name: `kunkun_$&#123;i&#125;`, alais: 'Irving', gender: 'female', education: 'senior high school', height: 'xxx', weight: 'xxx', hobby: 'xxx', tag: 'xxx', skill: &#123; sing: 0, dance: 0, rap: 0, basketball: 100, &#125;, &#125;)&#125;export default &#123; data: &#123; userList: user, &#125;, computed: &#123; firstUser() &#123; const userList = this.userList return userList.length ? userList[0] : &#123;&#125; &#125;, total() &#123; return this.userList.length &#125;, &#125;,&#125; 如以上代码所示，模拟了5万个用户，每一个用户拥有id, name, age等等字段。 jsfiddle 打开chrome devtool的Performance工具，可以看到，渲染这个组件的过程中，Observer这个阶段耗时2.19s（测试机器配置为桌面端i7，16g内存）。 接下来，我会一步一步的把这一段耗时减少到10ms。 分析原因众所周知，Vue在渲染组件的时候，会对data对象进行改造，遍历data的key，调用defineProperty方法定义它的setter和getter。如果某个字段是Object，或者Array，还会递归的对这个字段进行上诉操作。 通常情况下，这个操作耗时是很短的，但是当数据量非常大的时候，对每一个数据项的每一个字段都进行defineProperty的操作就是一个昂贵的操作，所以性能优化的出发点就是减少defineProperty的次数。 Step 1 - 减少无用字段在这个模拟的例子当中，其实我只需要2个字段，一个是name，一个是id（id甚至也可以不要），所以我把多余的字段都去掉，一共减少了8个String类型的字段，和一个Object类型的字段，可以减少 (8 + 4) * n次defineProperty操作和n次递归调用。看看结果如何。 Observer这个操作从2.2s减少到了515ms，提升还是比较大的。 Step 2 - 数据扁平化在当前版本（2.x）的Vue当中，对于数据变动的检测有许多限制，比如不能检测对象属性的添加和删除；不能检测到通过数据索引直接设置数据项等等。 所以，当一个数组的数据项都是基本数据类型的时候，Vue不会进行任何操作。 首先，把user数据拍扁 12345const user = []let i = 0while (i++ &lt; 50000) &#123; user.push(`kun_$&#123;i&#125;`, i) // 通过index为基数还是偶数分辨是name还是id&#125; 然后，相应的改变computed的计算方法，不影响渲染逻辑和业务逻辑 123456789101112...computed: &#123; firstUser() &#123; const userList = this.userList return userList.length ? &#123; name: userList[0], id: userList[1] &#125; : &#123;&#125; &#125;, total() &#123; return this.userList.length / 2 &#125;,&#125;... jsfiddle - 数据扁平化 看看结果如何 从上图可以看出，结果非常的明显，从515ms直接减少到了7ms，几乎完全避免了性能损耗。 Step 3 - 利用computed到此为止，性能上的问题已经解决了，但是扁平的数据会影响业务代码的开发效率和可读性，同时数据和它的index产生了深耦合，如果我们需要添加一个字段使用或者改变下顺序，很容易出问题。不过，我们可以利用computed计算属性把已经被拍扁的数据重新组装起来。由于Vue的响应式数据改造只针对data选项和props选项，不包括computed，所以只会产生很少的函数运行耗时。 12345678910111213141516171819202122232425262728293031export default &#123; data() &#123; return &#123; // 扁平的数据存起来 originSserList: user, &#125; &#125;, computed: &#123; firstUser() &#123; const userList = this.userList return userList.length ? userList[0] : &#123;&#125; &#125;, total() &#123; return this.userList.length &#125;, // 重新'组装'便于使用的计算属性，不影响原本的渲染和业务逻辑 userList() &#123; const result = [] const user = this.originSserList for(let i = 0; i &lt; user.length; i += 2) &#123; const name = user[i] const id = user[i + 1] result.push(&#123; name, id &#125;) &#125; return result &#125;, &#125;,&#125; 看看这种情况下的Performance。 仅仅只是多出了10ms的函数运行时间。 到这里，在无需改动任何的渲染逻辑和业务逻辑的情况下，将js的运行时间从2.2s减少到了10ms左右，提升了200倍。并且这些数据是在桌面端i7处理器下得到的，大大超越了绝大部分的用户的机器性能，更不用说移动端了，所以在实际的大数据量场景下，能取得更加明显的用户可感知的性能提升。 jsfiddle - 数据扁平化 + computed Step 4 - 数据静态化没想到吧，还有Step4？已经没有优化空间了呀。 在这个模拟的场景里面，确实没有优化的空间了，不过，并不是所有的数据都可以很好的进行扁平化处理，这可能涉及到方方面面的原因与权衡。那么这种情况下，如何进行优化呢？ 通常在Vue组件当中，都是把数据放在data选项当中，Vue会对data选项中的数据进行响应式改造，我称之”动态数据“或者”响应式“数据，但是并不是所有的数据都会发生变化的，很多时候，特别是大数据量场景下的数据是不会或者很少发生变化的，这种情况下，就没有必要把它放到data选项中去，在beforeCreated当中进行数据初始化，也不会影响数据的使用。 123beforeCreated() &#123; this.userList = xxx // 记得把data当中的userList删掉&#125; 这种处理方式，我称之为数据静态化，这种数据，我称之为”静态数据“。 但是，有一点需要特别的注意，静态数据并不在Vue的响应式系统当中，也就是说当你进行this.userList = newUserList时，视图不会重新渲染，对应的computed计算属性也不会重新计算。没有了Vue提供的响应式系统，如果数据变动的时候，我们需要手动的去计算对应的数据，可能还需要配合$forceUpdate这个api去重新渲染视图。此时，需要在性能和代码可读性与开发效率上进行取舍与权衡。 总结由于Vue的响应式系统，大数据量场景下可能会造成js运行层面的性能问题，可以通过3个方法去解决 减少无用字段 数据扁平化 数据静态化 这3个方法相互并不冲突，可以根据实际情况选择其中的1种或多种方法进行组合。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"moruo.vip/tags/Vue/"},{"name":"性能优化","slug":"性能优化","permalink":"moruo.vip/tags/性能优化/"}]},{"title":"hookEvent of Vue","slug":"hookEvent of Vue","date":"2019-06-04T14:22:20.000Z","updated":"2020-01-06T07:54:49.483Z","comments":true,"path":"2019/06/04/hookEvent of Vue/","link":"","permalink":"moruo.vip/2019/06/04/hookEvent of Vue/","excerpt":"在Vue当中，hooks可以作为一种event，在Vue的源码当中，称之为hookEvent。利用它，可以通过模板声明式的注入生命周期钩子函数，也可以给第三方组件添加生命周期处理函数。 1&lt;Table @hook:updated=\"handleTableUpdated\"&gt;&lt;/Table&gt;","text":"在Vue当中，hooks可以作为一种event，在Vue的源码当中，称之为hookEvent。利用它，可以通过模板声明式的注入生命周期钩子函数，也可以给第三方组件添加生命周期处理函数。 1&lt;Table @hook:updated=\"handleTableUpdated\"&gt;&lt;/Table&gt; 从一个场景出发有一个来自第三方的复杂表格组件，表格进行数据更新的时候渲染时间需要1s，由于渲染时间较长，为了更好的用户体验，我希望在表格进行更新时显示一个loading动画。 有一个粗暴的办法是直接修改这个组件的源码，利用beforeUpdate和updated来显示loading，但是这种办法非常不好 这是一个第三方的组件，作者发布组件的时候很可能对代码进行了压缩与构建，使得代码可读性很低，直接修改打包后的代码难度较高 如果有源码的话，可以fork一份自己修改，不过作者不一定会发布源码 无法享受开源社区对这个组件的升级与维护，你需要自己手动维护 总之，修改源码这个方案可行，但是不好，不优雅。那么，有没有办法，可以声明式的在模板上直接给一个组件注入一个生命周期函数呢？其实是可以的，就是通过hookEvent。 生命周期函数是如何工作的所谓生命周期函数，就是在某一个特定的时间点调用的函数，所以我们需要关注两件事：1、注册，2、调用。 我们首先从调用开始。 123456789vm._self = vminitLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, 'created') 上面是一段Vue的源码，可以看出，生命周期函数是通过callHook这个函数去调用的，自然而然，我们去看看callHook函数的代码 123456789101112131415export function callHook (vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] // 选项当中的生命周期函数 const info = `$&#123;hook&#125; hook` if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info) &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit('hook:' + hook) &#125; popTarget()&#125; 所以，callHook(‘created’)在vm._hasHookEvent为true的情况下，会执行$emit(‘hooks:created’)，也就是说，一个有着 hook: 特殊前缀的事件，会在对应的生命周期当中执行。其实到这里，我们已经可以大胆推断了：只要使用类似@hooks:created这个形式，就可以从Vue的模板中声明式的注入一个生命周期函数，测试一下，it works. 1&lt;Table @hook:updated=\"handleTableUpdated\"&gt;&lt;/Table&gt; hasHookEvent之前的大胆推断，忽略了一个条件，那就是_hasHookEvent必需为true，接下来就去看看这个_hasHookEvent 1234567891011121314151617const hookRE = /^hook:/ // 以hook:开头Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125; 当使用了$on方法监听事件时，如果事件名以 hooks: 作为前缀，那么这个事件会被当做hookEvent，注册事件回调的同时，vm._hasHookEvent会被置为true，当使用callHook调用生命周期函数时，由于_hasHookEvent为true，所以会$emit(‘hooks:xxx’)，注册的生命周期函数就会执行。 所以，如果你想给一个Vue组件添加生命周期函数有3个办法： 在Vue选项中添加 在模板中通过@hooks:created这种形式 vm.$on(‘hooks:created’, cb)或者vm.$once(‘hooks:created’, cb)","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"moruo.vip/tags/Vue/"}]},{"title":"localStorage操作指北","slug":"localStorage操作指北","date":"2019-02-13T13:29:00.000Z","updated":"2020-04-04T09:05:36.379Z","comments":true,"path":"2019/02/13/localStorage操作指北/","link":"","permalink":"moruo.vip/2019/02/13/localStorage操作指北/","excerpt":"localStorage提供了持久化的本地存储能力，但是由于年代久远，（getItem的签名是06年4月16日提交的），它的设计导致使用并不十分便利。在实际的使用当中，我们还需要解决2个问题： 序列化 溢出","text":"localStorage提供了持久化的本地存储能力，但是由于年代久远，（getItem的签名是06年4月16日提交的），它的设计导致使用并不十分便利。在实际的使用当中，我们还需要解决2个问题： 序列化 溢出 序列化localStorage把序列化/反序列话的职责丢给用户，个人认为是不符合用户使用习惯的，稍微复杂的场景用起来很蛋疼。后续HTML标准的其他持久存储功能，比如IndexedDB，是自带序列化和反序列化的。而且localStorage 标准最早的草稿里是带序列化/反序列化的，但后来定稿中去掉了，具体原因未知。 localStorage存储的是字符串类型的数据，当使用setItem的时候会调用数据的toString方法，也就是说 12[1, 2] =&gt; \"1, 2\"&#123;&#125; =&gt; \"[object Object]\" 合理的做法是，存储JSON格式的字符串，并在getItem/setItem自动进行的序列化/反序列化 溢出localStorage容量有限，为了安全的操作，避免溢出的情况发生，需要解决3个问题： 确定容量大小 如何知道溢出，溢出了之后浏览器的行为 如何确定一份数据将要占用的空间 容量大小标准当中并没规定具体的容量大小，只规定了用户代理，也就是浏览器必须限制容量，避免被恶意写入。 User agents should limit the total amount of space allowed for storage areas, because hostile authors could otherwise use this feature to exhaust the user’s available disk space. 同时，标准也规定了，当超过容量限制时，浏览器需要提醒用户，询问用户是否同意扩容。 User agents may prompt the user when quotas are reached, allowing the user to grant a site more space. This enables sites to store many user-created documents on the user’s computer, for instance. 显然，主流浏览器并没有按照标准去实现，那我们看看事实标准是怎样的。 localStorage可以存储的容量大小，通常被认为是5MB，但是安卓上手 Q 、手机QQ浏览器、微信中则是 2.5M 的数量级，因此在移动端，本地存储的 SIZE 更加珍贵。可以用这个网站测试localStorage的容量。 溢出了之后浏览器的行为我们已经提过，标准规定超过容量限制时，浏览器需要提醒用户，询问用户是否同意扩容。但是我没有发现有浏览器是如此实现的。 事实上，当localStorage溢出时，浏览器会抛出一个错误，并且不会存储这份数据，也不会覆盖现有数据。 那么问题来了，这个错误的错误码是什么，各浏览器是否一致呢？ 显然，它并不一致。有标准的情况下，各浏览器都有那么多不一致的情况，更别说这个没有标准的事情了。。。 网络上搜索的答案中，最常出现的答案是QUOTA_EXCEEDED_ERR，但是我在chrome当中测试的结果是QuotaExceededError，根据我的实验，和搜索的结果，如下的代码可供参考 123456789101112131415try &#123; localStorage.setItem(key, value)&#125; catch (e) &#123; const ERRORCODE = [ 'W3CException_DOM_QUOTA_EXCEEDED_ERR', 'QUOTA_EXCEEDED_ERR', 'NS_ERROR_DOM_QUOTA_REACHED', 'QuotaExceededError' ] if (ERRORCODE.includes(e.name)) &#123; // &#125; else &#123; // &#125;&#125; 如何确定一份数据将要占用的空间上述的一切告诉我们，要尽量避免localStorage存储空间的溢出。所以，当我们存储数据的时候，最好要做到心中有数 —— 这一份数据将会占用多少的空间呢。 已知：将要存储的数据a是string类型 求：a会占用多少空间 解： js的字符串使用utf-16编码，一个string占用2位，所以长度位n的字符串占用的空间就是n * 2 / 1024 kb 测试： 参考： webstorage标准 stackoverflow","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"moruo.vip/tags/javascript/"},{"name":"localStorage","slug":"localStorage","permalink":"moruo.vip/tags/localStorage/"}]},{"title":"从Dialog原理谈到Vue渲染原理","slug":"dialog","date":"2018-12-04T14:22:20.000Z","updated":"2020-01-06T07:54:49.483Z","comments":true,"path":"2018/12/04/dialog/","link":"","permalink":"moruo.vip/2018/12/04/dialog/","excerpt":"作为一个中后台表单&amp;表格工程师，经常需要在一个页面中处理多个弹窗。我自己的项目中，一个复杂的审核页面中的弹窗数量超过了30个，如何管理大量的弹窗就成为了一个需要考虑的问题。","text":"作为一个中后台表单&amp;表格工程师，经常需要在一个页面中处理多个弹窗。我自己的项目中，一个复杂的审核页面中的弹窗数量超过了30个，如何管理大量的弹窗就成为了一个需要考虑的问题。 大量的弹窗有什么问题假设你有一个弹窗组件，类似于element-ui的Dialog，如果简单粗暴的每一个弹窗都写一个dialog，那么会有以下问题： 模板过长，且大量冗余 命名困难，每一个弹窗需要一个变量去控制显示，通常每一个弹窗里面也是一个表单，又需要一个变量保存表单数据，每个弹窗也有自己的逻辑(method)，都要写在这个页面，要绞尽脑汁去取名 非常的不优雅，简直就是Repeat yourself反模式的示范。。。 把每个弹窗抽成模块一个很容易想到的优化方法就是把一个弹窗作为一个组件抽离出去，每个弹窗的逻辑单独写在组件中。 这样通过组件拆分做很好的解决了模板过长的问题，也基本解决了命名困难的问题，不过还是需要很多的变量去控制每个组件的显示。 使用动态Component第一个办法本质上并没有减少重复的代码和逻辑（弹窗显示/关闭），只是把代码放在了不同的文件当中。 显然，我并不需要写那么多的Dialog，Dialog本身并没有变，作为一个「包裹」组件，变的只是内容。 所以，只需要写一个dialog，配合Vue的动态组件Component，切换不同的组件就行了。 全局Dialog使用Component，我们做到了一个页面只需要一个Dialog，但其实整个网页，也只需要一个全局的Dialog。 我们在根组件下挂一个Dialog组件，组件内容依然使用动态component，组件的数据流转，component传递等使用Vuex进行。 使用函数创建组件作为单个项目的解决方案，全局Dialog加动态Component其实已经足够好了，使用一个函数调用就可以显示弹窗。 12345this.$dialog(&#123; title: '我是弹窗', component: Test, props: &#123; props &#125;, // Test的props通过这样传递&#125;) 但是想要作为通用解决方案，还不够： 引入不方便，需要手动在跟组件下引入并写上封装好的弹窗组件 必须使用Vuex进行数据流转，而并不是每个Vue项目都使用Vuex的 没法监听事件，只能传入回调 props的传递方式不够优雅，不够声明式 在我心中，一个理想的弹窗组件，需要是这样的： 引入方便，Vue.use(Dialog)就行了 使用简洁 1234this.$dialog(&#123; title: &apos;哎呀不错哦&apos;, component: () =&gt; &lt;Test onDone=&#123; this.fetchData &#125; name=&#123; this.name &#125;/&gt;&#125;) Let’s go. 使用$mountVue作为一个视图层的框架，核心其实就是渲染函数，所以一定有一个办法，可以把一个Vue组件渲染成一个DOM，这个方法就是$mount。 123456789101112131415161718192021222324252627282930313233343536373839// 这个Dialog组件就是写好的弹窗组件import Dialog from './Dialog'// dialog是一个单例，不需要重复创建let dialogexport default function createDialog(Vue, &#123; store = &#123;&#125;, router = &#123;&#125; &#125;, options) &#123; if (dialog) &#123; dialog.options = &#123; ...options, &#125; dialog.$children[0].visible = true &#125; else &#123; dialog = new Vue(&#123; name: 'Root-Dialog', router, store, data() &#123; return &#123; options: &#123; ...options &#125;, &#125; &#125;, render(h) &#123; return h(Dialog, &#123; props: this.options, &#125;) &#125;, &#125;) // 渲染出DOM并手动插入到body dialog.$mount() document.body.appendChild(dialog.$el) &#125; // 暴露close方法 return &#123; close: () =&gt; dialog.$children[0].close(), &#125;&#125; Dialog组件基于element-ui的Dialog组件二次封装，在原有的props之外，添加一个component，使用动态Component渲染上去就行了。思路很简单，但是有几个问题需要考虑。 生命周期问题如果不做任何处理，当弹窗消失的时候component并不会销毁；当再次显示弹窗时，会传入一个新的组件，这个时候，上一个组件才销毁，这非常不合理。所以我们需要在弹窗消失的时候手动销毁传入的component。 注入事件Vue的动态Component组件的is属性接受的值有3种类型： string，在当前组件内注册过的组件的名称 ComponentDefinition，就是一个组件的选项对象，new Vue时传的那个对象 ComponentConstructor，返回一个ComponentDefinition的函数，比如动态import函数 而我们希望的调用形式里，component是一个返回jsx的函数，而它会被babel插件babel-plugin-transform-vue-jsx转换为调用createElement函数的结果，也就是说1() =&gt; &lt;Test &gt; 这个函数最终返回的是一个Virtual Node。而Vue的选项里面,render最终返回的也是一个VNode。也就是说，() =&gt; 这个函数可以作为一个Vue组件的render选项，所以，我们需要构造一个完整的Vue选项对象，然后将这个对象作为动态component的is属性，这样就可以渲染出这个Test组件了。 在这个过程中，我们可以在这个Vnode里面做一些有趣的事情，比如注入事件。 为什么要注入事件首先，这里有一个刚需：弹窗内的组件需要可以关闭弹窗，也就是它的父组件。通常有两个办法可以做到： 通过props接收一个函数，调用它可以关闭弹窗 主动抛出一个事件，dialog组件监听这个事件，然后把自己关了 略微比较一下就可以发现，抛出事件的方法优于回调函数的办法（通常来说，「事件」都优于「回调」）： 代码少, $emit(‘complete’)就行了，使用回调需要添加一个props，调用的时候还需要判断它是否存在 通用性更好，这个组件可能不仅仅只在弹窗内调用，它可以在其它任何地方被调用，使用事件只需要简单的抛出一个事件，表示我完成了，调用它的组件根据自身的逻辑来进行接下来的工作，这样组件本身做到了低耦合。 但是，抛出事件的实现却要比传入回调难很多，需要对VNode比较熟悉。 在Dialog组件内，我们触及不到组件的模板，所以简单的在动态component模板上添加 @done 并不能完成事件监听。因为事件监听其实是在render的过程中进行的，而我们的render是通过jsx的方式在调用$dialog函数时传入的，所以只能手动在生成的VNode上添加事件监听： 在 vNode.componentOptions.listeners中，添加我们需要监听的事件和事件处理函数: 1234567891011121314151617181920let listeners = vNode.componentOptions.listenersif (!listeners) &#123; listeners = &#123;&#125; vNode.componentOptions.listeners = listeners&#125;// 添加doneconst orginDoneHandler = listeners.donelisteners.done = function () &#123; if (orginDoneHandler) orginDoneHandler() doneHandler()&#125;// 添加cancelconst orginCancelHandler = listeners.cancellisteners.cancel = function () &#123; if (orginCancelHandler) orginCancelHandler() cancelHandler()&#125; 在Dialog中，监听了动态component的done和cancel事件，在任一事件触发后都会关闭Dialog，组件$emit(‘done’)表示完成了自己的业务，$emit(‘cancel)表示取消了自己的业务 主动收集依赖到这里，还有一个问题没有解决：这个组件还不是响应式的，比如说，你在一个index组件中通过$dialog显示一个弹窗 1234this.$dialog(&#123; title: '响应式', component: () =&gt; &lt;Test text=&#123; this.text &#125;/&gt;&#125;) 当text更新时，弹窗中的内容并没有更新，也就说，组件没有重新渲染。 Vue的渲染流程与依赖收集这里就要涉及到一些Vue的原理了，比如说渲染流程，依赖收集，一两句话也讲不清楚，我试着大概的说一下： 首先，页面上显示的数据变了，一定是触发了重新渲染，this.text = ‘新的text’ 之所以会更新页面，可以理解为一个渲染函数在this.text的setter中执行了。 那么，this.text的getter怎么样才能知道要执行哪些函数，就是通过所谓的依赖收集。简单来说，依赖收集是在渲染函数（渲染Vnode的函数）中进行的，在createElement中一旦通过this.text使用了这个变量，通过这个变量的getter就收集到了正在执行的渲染函数这一个依赖。 所以，粗暴的讲，需要把this.text的访问放在一个render函数（Vue选项对象的render）中进行。平常用的模板其实也是这样，因为它最终都被Vue-loader编译成了render。 12345678910111213141516_component() &#123; // 这一步很重要，让component收集到了这个计算属性的依赖，否则当component变化时不会重新渲染组件 const fn = this.component let vNode // 返回vue选项对象 const that = this return &#123; name: 'dynamic-wrapper', render() &#123; // fn的运行一定要在render函数中，也是为了挂载依赖 vNode = fn() ... &#125;&#125; 所以，这就是为什么一定要使用一个返回jsx的函数作为，而不是直接美滋滋的使用jsx。因为，臣妾实在是做不到响应式呀~ 1234this.$dialog(&#123; title: '臣妾做不到啊~', component: &lt;Text text=&#123; this.text &#125;/&gt;,&#125;) 等于12345678910// this.text的值为textthis.$dialog(&#123; title: '臣妾做不到啊~', component: createElement( Text, props: &#123; text: 'text', &#125; )&#125;) 完整代码，拍着胸脯保证可用，已经在生产环境大量使用超过3个月的时间了。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"moruo.vip/tags/Vue/"},{"name":"dialoag","slug":"dialoag","permalink":"moruo.vip/tags/dialoag/"},{"name":"Vue渲染原理","slug":"Vue渲染原理","permalink":"moruo.vip/tags/Vue渲染原理/"}]},{"title":"你可能对virtual-dom存在误解","slug":"你可能对virtual-dom存在误解","date":"2018-11-29T16:10:00.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2018/11/30/你可能对virtual-dom存在误解/","link":"","permalink":"moruo.vip/2018/11/30/你可能对virtual-dom存在误解/","excerpt":"下面这段代码，会产生什么样的结果? 1234567function sleep(time) &#123; const start = Date.now() while (Date.now() - start &lt; time * 1000) &#123;&#125;&#125;document.body.style.background = 'black'sleep(5)","text":"下面这段代码，会产生什么样的结果? 1234567function sleep(time) &#123; const start = Date.now() while (Date.now() - start &lt; time * 1000) &#123;&#125;&#125;document.body.style.background = 'black'sleep(5) 再来 1234document.body.style.background = 'blue'sleep(2)document.body.style.background = 'red'sleep(3) 异步吗？batch更新吗？更改了dom对象，浏览器也并不会立刻立马去渲染，那么，js所能触及到的dom对象，在浏览器层面，是否也是virtual-dom呢？给浏览器写代码的人各各都是人才，这种性能优化肯定是会做的。 什么是virtual-dom网页是什么，我认为是信息的载体，而html + css生成的dom，就是一种结构化表达信息的数据结构，是浏览器对信息的抽象。 那么这种抽象只有dom一种吗？当然不是，它可以有无数种，只要能够完整的表达结构化的信息就行，它可以跟dom结构类似，是一棵树，比如传统的virtual-dom实现；理论上它也可以是其它的数据结构。 所以，我认为一个可以完整描述信息的对象，就是virtual-dom 为什么需要virtual-dom是react将virtual-dom这个概念带进了我的视野，所以我尝试从react的角度来看为什么需要virtual-dom。 1view = f(state) 从函数式编程的角度来讲，不同的state经过渲染函数，就会产生不同的UI，所以理想状况下，状态变了，重新渲染一个，整体替换掉就ok了。 然而，理想很丰满，现实却是dom操作性能不佳，简单粗暴的全量更新会带来明显的性能问题。解决这个问题，很容易的想法是维护状态–&gt;追踪变化–&gt;部分更新。 这样的思路没有问题，angular和vue 2.x之前的版本都是这样做的，核心思路就是细粒度的绑定：每一部分状态对应一部分UI，当这一部分状态变了，通过绑定关系找到对应的ui，进行相应的更新。 但是这样的思路很不函数式，和react的基本思路背道而驰，而且这个过程，会让本来清晰明了的渲染过程变得复杂，需要引入watcher, dependency tracking，脏检查，建立绑定等等。 而计算机领域的所有问题，都可以通过引入一个中间层来解决，通过引入virtual-dom，保持了view = f(state) 的纯粹，view变成了virtual-dom。当状态变化的时候，不从追踪状态变化–&gt;响应变化这个角度去考虑问题，而从diff最终渲染结果这个角度来思考。 关于virtual-dom的性能谣言似乎提及virtual-dom，很多人的印象就是性能高效，什么O(n)的diff啦，batch修改啦，dom操作慢啦等等。但是，virtual-dom的性能并不突出，尤其是react的实现。 不管采用什么样的手段，最终还是得调用dom api，而且最终进行的dom操作只会更多，不会更少，原生的总是更快，这毫无疑问。 react从没有宣传过自己是一个高性能的框架，因为它的性能确实并不突出，拿它和我熟悉的Vue做个比较： 初始渲染：virtual-dom胜 因为vue需要对对象进行「改造」，设置getter，setter，watcher,收集依赖，这些都有开销 数据更新：vue &gt; virtual-dom vue通过依赖收集，能够「精确定位」，进行局部更新，非常高效，就像精确制导导弹。 而virtual-dom需要重新渲染整个组件，然后同步遍历新旧、组件进行diff，然后拿到diff的结果进行patch，patch的过程中通常也需要对dom进行遍历。这个过程像是扫描战场，发现目标。 特别是当小数据量更新的时候，vue的依赖收集性能优势非常明显。更不用说react还有无法解决的跨层级移动，和解决的很不好的列表顺序变化的性能问题。 所以vue早期打出了「高性能」的旗号，确实是在大部分场景下，性能都优于react，不过依赖收集也不是免费的，所以初始渲染会比react慢。 但是，virtual-dom确实解决了react状态更新的渲染性能问题，在坚持view = f(state)这个条件下，做到了局部更新。 virtual-dom的意义尤雨溪大大的看法我觉得非常正确，搬运如下： 在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative 我想第二点也是vue引入virtual dom的理由吧。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"moruo.vip/tags/javascript/"},{"name":"virtual-dom","slug":"virtual-dom","permalink":"moruo.vip/tags/virtual-dom/"},{"name":"react","slug":"react","permalink":"moruo.vip/tags/react/"}]},{"title":"对于递归的傲慢与偏见","slug":"对于递归的傲慢与偏见","date":"2018-11-08T14:28:21.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2018/11/08/对于递归的傲慢与偏见/","link":"","permalink":"moruo.vip/2018/11/08/对于递归的傲慢与偏见/","excerpt":"最近刷leetcode 79题 Word Search需要用到DFS算法，由于是刷leetcode，心想不能用递归，影响效率，于是利用stack完成。之后又利用递归（使用cache）实现了一次，结果竟然是递归的算法比非递归更快。","text":"最近刷leetcode 79题 Word Search需要用到DFS算法，由于是刷leetcode，心想不能用递归，影响效率，于是利用stack完成。之后又利用递归（使用cache）实现了一次，结果竟然是递归的算法比非递归更快。 「低效」的递归对于递归，通常会有效率低下的映像，一般是因为2点： 重复计算 函数调用开销 对于重复计算，可以缓存计算结果来解决。 对于函数调用开销，可以利用「尾递归」来解决，不过目前的v8引擎并没有实现对尾递归的优化，所以最开始我以为递归没有理由比非递归更快。 递归与堆栈非递归的DFS算法使用一个「堆栈」来实现。而同样，函数调用也是利用「栈」来完成。 首先，Javascipt并没有原生的堆栈这个数据结构，通常是利用数组来实现，效率上应该会有所损失。 其次，系统堆栈快于手动堆栈是没有疑问的，而且系统堆栈使用的是寄存器，比内存要快很多。 最后，函数调用会有额外开销这个是没法避免的，但是当函数变量不多，递归层级不深的时候，这个开销带来的效率损失不能抵消系统堆栈带来的效率提升。 综合来看，在不爆栈的情况下，大部分Javascript代码里使用了缓存的递归在算法效率上高于非递归算法，并且递归算法的表现力是完全高于非递归的。很多时候，出于臆断进行的所谓优化，完全是负优化。 关于递归的随想之前在看SICP的时候，发现函数式编程没有循环，非函数式语言的循环操作都是利用「递归」的形式来完成的。而且所有的递归，都可以改成迭代的形式，避免了递归重复计算的缺点，也无需使用缓存来加速递归的计算，省下了缓存的开销，所以有句话叫做“所有循环都是尾递归”。 总结 惯性思维不可取，实践检验真理 递归 !== 慢 以后图的遍历、树的遍历、巴拉巴拉其它情况，直接写递归，谁怼我说递归效率低，就让他来solo。（莫名的开心咋回事儿啊？） 以上关于为什么递归快的推理全是推断，但是DFS非递归慢于递归是事实（Javascript中）。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"moruo.vip/tags/algorithm/"},{"name":"recursion","slug":"recursion","permalink":"moruo.vip/tags/recursion/"}]},{"title":"减小发布到npm包的体积与避免重复依赖","slug":"减小发布到npm包的体积与避免重复依赖","date":"2018-11-06T12:20:20.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2018/11/06/减小发布到npm包的体积与避免重复依赖/","link":"","permalink":"moruo.vip/2018/11/06/减小发布到npm包的体积与避免重复依赖/","excerpt":"这两天一直在忙于封装一个vue table组件并发布到npm，记录一下我是如何把npm包的大小从100多kb减小到不足1kb的过程。","text":"这两天一直在忙于封装一个vue table组件并发布到npm，记录一下我是如何把npm包的大小从100多kb减小到不足1kb的过程。 背景这个组件底层依赖于element-ui，使用了其table组件和pagination组件，最终的组件是一个完全通过配置来描述每一列的表格组件。最开始我发布的是打包之后的代码。如果使用的这个组件的项目中没有引入过element-ui组件，那么不会造成任何重复的依赖，直接引用打包后的版本。但是如果项目本身已经引入了完整的element-ui(我们公司使用这个组件的10余个系统均引入了完整的element-ui)，那么很明显会造成代码的重复，会使bundle增加90kb(未压缩时)。 我们需要发布经过打包之后的代码吗如果发布的经过打包后的组件，是没办法避免重复依赖的。如果可以像把源代码直接copy到项目再import引入这样，就可以避免重复的依赖了。这个可以使用package.json中的module字段来完成。 当package.json中存在module字段时，会优先寻找module对应的文件，并使用ES模块规范处理。 我们可以把未经过打包的源代码发布到npm，并把package.json中的module字段指向源代码，这样引入的package就交由项目的构建工具（webpack, babel）来进行处理，因此理论上就可以避免重复依赖了。 使用module字段是否会有副作用有可能，因为webpack插件可以配置exclude字段，如果项目的webpack配置exclude掉了node_modules，就会产生副作用。比如可能未经babel转码成es5代码（我发布的这个组件目前只会存在这样一种可能的副作用）。 如何解决副作用 babel转码后再发布 在readme中指出，让用户取消掉babel的exclude 判断重复依赖的机制到目前为止，还并不能解决重复依赖的问题。。。这是因为重复依赖的判断机制.Node.js中相同模块是否会被加载多次？ nodeJs是根据模块的路径来判断是否为同一依赖的，而大家都知道node.js会从当前模块所在目录的node_module开始找起，如果没找到再会去找上级目录的node_modules，直到根目录为止。那么问题就来了。 我发布的包里面dependencies里包含element-ui，这没问题，我确实依赖了element-ui。那么install包时，会根据我写明的dependencies下载element-ui并放在包的node_modules里面。所以这个包引用的element-ui和项目本身引用的element-ui由于path不同被认为是不同的依赖，于是都被打包进了bundle里面造成了重复依赖。 如何解决方法1，在项目的babel配置中添加按需引入element-ui的配置，但是这个方法需要修改项目的配置，比较繁琐，我维护的10来个系统需要一个一个去改，太麻烦了。。。。 方法2，很简单，把发布的包的package.json的dependencies的element-ui和Vue删掉(如果你使用webpack打包你的库，可以使用「externals」)，这样npm install的时候就不会下载element-ui到包的node_modules,就是往上级目录找，直到项目node_modules里面的element-ui，这样，包引用的element-ui和项目引用的element-ui就是同一个依赖，就不会重复打包这和vue-cli3打包的库不会包含Vue依赖是同一个原理。最终的结果就是最终生产环境打包后的chunk-vender.js仅仅增加了不到1kb。 不过这样也造成了一定的问题，那就是本身不使用element-ui的项目需要手动引入打包之后的发布的文件。不过不使用element-ui组件的项目使用这个表格组件的收益和概率都不高，如果真的要用的话，单独再发布一个完全打包之后的包，也能快速解决问题。 总结通过这两天的折腾，主要收获有4点1、发布npm包的流程2、package.json中的module字段3、判断重复依赖的机制4、基于ui组件封装组件时如何避免重复依赖","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"npm","slug":"npm","permalink":"moruo.vip/tags/npm/"},{"name":"优化","slug":"优化","permalink":"moruo.vip/tags/优化/"}]},{"title":"开发一款无副作用的Chrome高亮插件","slug":"开发无副作用的Chrome高亮插件","date":"2018-10-14T13:03:20.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2018/10/14/开发无副作用的Chrome高亮插件/","link":"","permalink":"moruo.vip/2018/10/14/开发无副作用的Chrome高亮插件/","excerpt":"审核业务的同事需要一款chrome高亮插件来加快审核，由于涉及到敏感的数据，因此不放心第三方的插件，并且调研发现很多chrome商店的高亮插件并不能兼容使用mvvm框架编写的网页，都存在一定的副作，用当被高亮的内容被修改时会造成信息显示错误，于是决定自己开发一个。 GitHub","text":"审核业务的同事需要一款chrome高亮插件来加快审核，由于涉及到敏感的数据，因此不放心第三方的插件，并且调研发现很多chrome商店的高亮插件并不能兼容使用mvvm框架编写的网页，都存在一定的副作，用当被高亮的内容被修改时会造成信息显示错误，于是决定自己开发一个。 GitHub Chrome插件总的来说，Chrome插件的开发完全是前端的技术，跟写一个网页、js类库并没有区别，一个前端技能娴熟的程序员可以在简单阅读文档后迅速进行Chrome插件的开发。 content_scriptChrome插件提供在网页中注入js代码（xss既视感）的能力，这些js代码就是content_script。注入的js代码和网页本身的js代码可以理解为不在同一个作用域，不能直接交互，但是可以访问DOM。高亮就是由content_script操作DOM实现。 popuppop_up就是点击插件图标时出现的页面，在高亮插件里，这个页面用来输入高亮关键字、控制插件开关。 storage与通信chrome提供了用于存储和通信的api。 storage分为local, sync, managed 3种类型。local类似于localStorage，sync在登录了google账号的情况下会把数据存放在云端，若未登录则使用local。需要注意2点：1. chrome stroage的操作是异步的。2. 存放的数据自动进行了parse，不像localSrorage存储的是String。 通信的api用于content_script、popup、background之间的通信。 以上就是开发一款chrome高亮插件需要了解的知识点。仅仅使用了chrome插件可以使用的一小部分能力。 高亮算法在页面展示文本一般有两种途径： TextNode 利用input的value或者placeholder(百度首页的「百度一下」按钮就是使用input的value做的) 通常来说input标签的属性我们是不能乱动的，所以只需要关注TextNode。 给定一个关键字列表 1keyWrods = ['我', '爱', '她'] 给定一个文本节点及其父节点 1&lt;p&gt;其实，我真的爱着她&lt;/p&gt; 比较自然的思路是使用字符串的replace方法进行正则匹配就可以完成高亮了。所以这里有两个问题： 生成正则 完成高亮 生成正则只有一点需要注意，特殊字符需要进行转义，比如”/“、”.”等等 1234567891011121314const getRegFromStrList = (function () &#123; const metaStrInReg = [ '*', '^', '$', '*', '+', '?', '&#123;', '&#125;', '?', '.', '(', ')', '!', '|', '\\\\', ] const reg = new RegExp(metaStrInReg.map(s =&gt; `\\\\$&#123;s&#125;`).join('|'), 'g') return arr =&gt; &#123; if (!Array.isArray(arr)) return false if (arr.length === 0) return false const regStr = arr.map(str =&gt; str.replace(reg, match =&gt; `\\\\$&#123;match&#125;`)).join('|') return new RegExp(regStr, 'g') &#125;&#125;)() 高亮单个文本节点把匹配到的字符外面包裹一个wrap元素添加高亮的样式，然后整体替换到这个文本节点就可以了，由于做的是一个chrome插件，所以使用了一个只有chrome支持的实验性api: node.replaceWith，可以非常方便完成节点的替换操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344let reg = getRegFromStrList(keyWords) // 高亮单个text-nodeconst highlightTextNode = node =&gt; &#123; if (!reg) return if (node.nodeType !== 3) return text = node.data if (text.search(reg) === -1) return const styleTypeCount = 6 // 样式种类数量 const gethighLightTagHead = i =&gt; &#123; const index = i % styleTypeCount + 1 return `&lt;span\\ class=\"_higtlight_chrome_extension_mor _higtlight_chrome_extension_mor__style__$&#123;index&#125;\"\\ data-highlighted=\"1\"&gt;` &#125; const highLightTagTail = '&lt;/span&gt;' const newElement = document.createElement('morun') // 生成有高亮样式的dom元素 newElement.innerHTML = text.replace(reg, match =&gt; &#123; const index = keywords.indexOf(match) if (index &gt; -1) &#123; return `$&#123;gethighLightTagHead(index)&#125;$&#123;match&#125;$&#123;highLightTagTail&#125;` &#125; &#125;) // 保留原始文本节点，但是清除它的内容，不让原来的文本内容显示 node.textContent = '' // 这次的mutation不用追踪，不能触发下一轮的replacedNodeObserver，否则会清除高亮 node.needTrack = false // 利用micro-queue的优先调度 setTimeout(() =&gt; node.needTrack = true) // 在已经是空的文本节点之前插入高亮节点，完成高亮 node.before(newElement) originTextNodes.push(node) node.responsedNode = newElement replacedNodeObserver.observe(node, &#123; 'childList': true, 'characterData': true, 'subtree': true, 'attributes': true, &#125;) observerRemove(node)&#125; 遍历DOM遍历DOM，对每一个文本节点使用刚才的高亮算法，就完成了高亮。 有两种思路对DOM进行遍历。 遍历document.all 遍历DOM树 我采用的是层序遍历DOM的方法。有一点需要注意的是需要忽略掉一些特殊的标签，比如script, style，meta等等。 观察DOM变动Mutation ObserverMutation Observer 就是一个观察DOM变动的API，可以观察所有的DOM变动，包括属性，子孙节点，文本等等。 需要注意在每一个event-loop中，所有的DOM变动会进行合并，并不会多次触发，而且这个回调是异步的，并且是在micro-task中。 这一点非常重要，因为每高亮一个节点，就会产生一次DOM变动，如果每一次文本变动都会触发Mutation Observer，就会造成性能问题，而且，由于回调在micro-task中，使用throttle也不能很好的解决，因为通常的throttle是使用setTimeout来实现的。 标记已被高亮的node在遍历DOM的过程，需要跳过已经被高亮过的节点，因为在遍历DOM进行高亮之后会造成DOM变动，所以在这一个tick执行完之后，会进入micro-task再执行高亮函数，由于匹配到关键字的文本一直存在，又会继续进行高亮，一直无限循环下去。 所以对需要更新高亮算法，把已被高亮的节点做一个标记，遍历DOM的时候遇到标记就跳过。 如何取消高亮高亮之后，肯定需要能够取消，比如要提供一个开关，控制高亮插件的关闭，比如更新关键字的时候需要把DOM回退。 在进行高亮的时候，使用一个数组把这个textNode存起来，并且在textNode上添加一个responsedNode属性，指向的就是替换掉这个textNode的元素。当需要取消高亮的时候，遍历这个数组，替换回去就可以了。 在MVVM下工作现在很多的网站是使用MVVM框架写的，比如\u001cVue, React等等，框架会把很多DOM对象和一个javascript对象（virtual dom、数据）对应起来，当数据变化时更新（渲染）页面，比如使用textNode.textNode = newText。那么问题来了。 建立对应关系是在模板解析阶段完成的，这个时候并没有渲染DOM，高亮插件也没有对DOM进行过改变。当网页渲染好，高亮函数进行高亮的时候，我们「替換」掉了textNode，textNode是什么，就是一个对象，而框架保留的是对被我们替换掉的textNode的引用，所以当数据更新后，页面并不会发生变化，这就很尴尬了。不过既然发现了造成问题的原因，那么就好解决了。 观察被替换掉的节点思路很简单，当被替换掉的文本节点有变动的时候，我们把它换回去就OK了。 我首先尝试的是使用Object.defineProperty定义setter来解决，不过显然是我天真，textNode的textContent属性是non-configurable的，无法重新定义。 so，还是拿起了之前用过的Mutation Observer武器，问题解决。当对一个文本节点进行高亮的时候，使用Mutation Observer对它进行观察，当发生变动时把原文本节点替换回去，这一次的替换又会造成一次DOM变动触发Mutation Observer，对新的文本进行高亮。 观察被替换掉的节点父节点现在还有一个问题，一个节点本身被移除这个操作是没法通过观察它自己来监测到的，只能通过观察它的父节点来完成，所以还需要观察被替换掉的节点父节点，当观察到这个节点被移除是需要同步移除高亮节点。 总结通过这个项目还是学到了不少东西，知识水平得到了提高。 Chrome插件的开发 Mutation Observer mvvm的渲染流程 正则处理 熟悉了更多的DOM API","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"moruo.vip/tags/javascript/"},{"name":"chrome插件","slug":"chrome插件","permalink":"moruo.vip/tags/chrome插件/"},{"name":"Mutation Observer","slug":"Mutation-Observer","permalink":"moruo.vip/tags/Mutation-Observer/"}]},{"title":"Axios统一错误处理与后置","slug":"Axios统一错误处理与后置","date":"2018-09-25T07:22:21.000Z","updated":"2020-01-06T07:54:49.483Z","comments":true,"path":"2018/09/25/Axios统一错误处理与后置/","link":"","permalink":"moruo.vip/2018/09/25/Axios统一错误处理与后置/","excerpt":"在进行业务开发的时候，前后端会对接口的数据结构进行约定，若接口有异常，需要将异常信息展示给用户知晓。这个流程里，数据结构是确定的（事先约定），数据的处理逻辑是相同的（展示给用户），如果在业务代码代码中重复的catch(e) { 展示给用户 }，就非常的不优雅。本着Don’t repeat myself（懒）的原则，需要对接口错误进行统一处理。","text":"在进行业务开发的时候，前后端会对接口的数据结构进行约定，若接口有异常，需要将异常信息展示给用户知晓。这个流程里，数据结构是确定的（事先约定），数据的处理逻辑是相同的（展示给用户），如果在业务代码代码中重复的catch(e) { 展示给用户 }，就非常的不优雅。本着Don’t repeat myself（懒）的原则，需要对接口错误进行统一处理。 业务场景 后端通过http状态标识接口状态，错误信息在response的data里 前端的处理逻辑是使用element-ui的Message展示错误信息 使用axios axios可以通过拦截器，在业务代码处理响应之前对响应进行处理,类似于下面的流程 123someAPI() .then(interceptorsFn) .then(业务逻辑) 所以，我们可以在interceptors对响应进行统一处理:1234567891011121314151617request.interceptors.response.use( (response) =&gt; response.data, (error) =&gt; &#123; // 针对特定的http状态码进行处理 if (error.response &amp;&amp; error.response.status === 401) &#123; router.push(&#123; name: &apos;ssoLogin&apos; &#125;) return new Promise(() =&gt; &#123;&#125;) // pending的promise，中止promise链 &#125; ..... const msg = error.response.data Message.error(msg) return Promise.reject(error.response) &#125;) 如何进行特定的错误处理不难看出，上面的方案有一个问题，如果有某个接口需要有业务代码来展示定制的错误信息（这个情况十分常见），如何处理？ naive方案1：业务代码使用其它的方式展示信息：例如Notify。这个方案被我司产品痛骂，因为破坏了统一的错误信息展示，并且此时统一的错误信息是一个垃圾信息，没必要展示。 naive方案2：业务代码直接使用Message，顶掉统一的错误信息。这个方案还是被产品大哥（dog）怼了，因为明显的用户体验不好，错误信息出现了闪烁。 帅气的解决方案3：业务代码决定是否隐藏统一错误提示那么问题来了，由于是先走拦截器，再走业务代码，如何由业务代码决定是否隐藏统一错误提示呢？我的办法是，将统一的错误提示使用setTimeout放到下一个loop执行，并通过一个变量标识是否要执行统一错误提示。 1234567891011request.interceptors.response.use( (response) =&gt; response.data, (error) =&gt; &#123; ... setTimeout(() =&gt; &#123; if (tag) &#123; Message.error(msg) &#125; &#125;) &#125;) 接下来，需要考虑的是，如何在业务代码里改变标识变量 naive方案1：一个全局的变量或者方法这个方案非常的不靠谱，若在其它代码里改变了这个全局变量，就嗝屁，并且N个接口公用一个标识变量，只能是同一个状态。 帅气方案2：1234567891011121314151617request.interceptors.response.use( (response) =&gt; response.data, (error) =&gt; &#123; ... let isShowNormalError = true const hideNormalError = () =&gt; isShowNormalError = false setTimeout(() =&gt; &#123; if (isShowNormalError) &#123; Message.error(msg) &#125; &#125;) // 在error.response上添加方法 return Promise.reject(&#123; ...error.response, hideNormalMessage &#125;) &#125;) 业务代码: 123456someAPIFN() .then() .catch(&#123; data, hideNormalMessage &#125;) &#123; // 业务代码 hideNormalMessage() &#125; 兼容旧代码目前的方案需要对现存代码做修改，对进行特殊处理的接口添加hideNormalMessage()。如果不想全局搜索添加代码（懒），可以根据业务来进行兼容。下面讲一下我结合业务代码进行的兼容处理（非常不推荐）。 12345678910111213141516171819202122232425request.interceptors.response.use( (response) =&gt; response.data, (error) =&gt; &#123; // warning，和业务代码深度耦合，不推荐 const hasMessageBeforeCatch = !!document.querySelector(&apos;.el-message&apos;) ... let isShowNormalError = true const hideNormalError = () =&gt; isShowNormalError = false setTimeout(() =&gt; &#123; const hasMessageAfterCatch = document.querySelector(&apos;.el-message&apos;) // 调用catch前没有message，调用catch后有message，表示message是在catch过程中产生 const madeMessageWhenCatch = !hasMessageBeforeCatch &amp;&amp; hasMessageAfterCatch if (isShowNormalError &amp;&amp; !madeMessageWhenCatch) &#123; Message.error(msg) &#125; &#125;) return Promise.reject(&#123; ...error.response, hideNormalMessage &#125;) // 在error.response上添加方法 &#125;) 逻辑：如果在catch中使用了Message，就不展示统一错误处理 总结这个解决方案的关键在于使用setTimeout使得统一错误处理“落后”于业务代码，并在Promise.reject的参数中添加控制函数使得业务代码可以决定是否展示统一错误处理。稍作抽象与封装就可以形成一个业务无关、框架无关的统一错误处理方案。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"axios","slug":"axios","permalink":"moruo.vip/tags/axios/"},{"name":"ajax","slug":"ajax","permalink":"moruo.vip/tags/ajax/"}]},{"title":"soft-bind 函数","slug":"soft-bind","date":"2018-09-16T13:05:00.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2018/09/16/soft-bind/","link":"","permalink":"moruo.vip/2018/09/16/soft-bind/","excerpt":"什么是softBind原生的bind函数在进行多次bind时，始终以第一次的bind为准 12345678function foo() &#123; console.log(this.bar)&#125;foo = foo.bind(&#123; bar: 'first' &#125;)foo = foo.bind(&#123; bar: 'second' &#125;)foo() // first softBind就是多次bind时，后面的覆盖前面的","text":"什么是softBind原生的bind函数在进行多次bind时，始终以第一次的bind为准 12345678function foo() &#123; console.log(this.bar)&#125;foo = foo.bind(&#123; bar: 'first' &#125;)foo = foo.bind(&#123; bar: 'second' &#125;)foo() // first softBind就是多次bind时，后面的覆盖前面的 12345678function foo() &#123; console.log(this.bar)&#125;foo = foo.softBind(&#123; bar: 'first' &#125;)foo = foo.softBind(&#123; bar: 'second' &#125;)foo() // second 为什么简单使用call/apply不行简单实现一个bind 1234567891011121314Function.prototype.softBind = function(obj, arg)&#123; var that = this return function() &#123; return that.call(obj, arg) &#125;&#125;function foo() &#123; console.log(this.bar)&#125;foo = foo.softBind(&#123; bar: 'first' &#125;)foo = foo.softBind(&#123; bar: 'second' &#125;)foo() // first 多次bind的执行就像一个栈一样，最后的bind最先执行，所以最后一次调用call绑定this的对象，永远是第一次bind的值，跟koa的「洋葱模型」也有点像。多次bind的执行流程可以简化为下面的伪代码 123456foo () &#123; this = &#123; bar: 'second' &#125; // 第二次绑定 this = &#123; bar: 'first' &#125; // 第一次绑定 执行foo&#125; softBind实现思路如下： 判断是否已经绑定，如果已经绑定，则不在绑定到新的对象 判断是否已经绑定执行bind的时候，如果已经绑定了this，调用call/apply时直接传this，否则，传绑定的对象。 那么，如何判断是否绑定了this呢？ 当未进行任何显示、隐示绑定时，this的值有3种可能： undefined (严格模式下) window (非严格模式下) global (node) 所以，只要this不是这3者之一，那么就说明进行了绑定 1234567891011121314151617Function.prototype.softBind = function (obj, ...args) &#123; const fn = this const curried = args return function (...args) &#123; // 如果已经绑定了this，把这个绑定向下传递 const target = ( !this || (typeof window !== \"undefined\" &amp;&amp; this === window) || (typeof global !== \"undefined\" &amp;&amp; this === global) ) ? obj : this return fn.apply( target, [...curried, ...args] ) &#125;&#125;","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"moruo.vip/tags/javascript/"}]},{"title":"实现一个符合Promise/A+标准的Promise","slug":"promise","date":"2018-06-23T15:12:21.000Z","updated":"2020-01-06T07:54:49.484Z","comments":true,"path":"2018/06/23/promise/","link":"","permalink":"moruo.vip/2018/06/23/promise/","excerpt":"– What i can’t create, i don’t understant 前言实现Promise的目的是为了深入的理解Promies，以在项目中游刃有余的使用它。完整的代码见gitHub","text":"– What i can’t create, i don’t understant 前言实现Promise的目的是为了深入的理解Promies，以在项目中游刃有余的使用它。完整的代码见gitHub Promise标准Promise的标准有很多个版本，本文采用ES6原生Promise使用的Promise/A+标准。完整的Promise/A+标准见这里，总结如下： promise具有状态state(status)，状态分为pending, fulfilled(我比较喜欢叫做resolved)， rejected。初始为pending，一旦状态改变，不能再更改为其它状态。当promise为fulfilled时，具有value；当promise为rejected时，具有reason；value和reason都是一旦确定，不能改变的。 promise具有then方法，注意了，只有then方法是必须的，其余常用的catch,race,all,resolve等等方法都不是必须的，其实这些方法都可以用then方便的实现。 不同的promise的实现需要可以相互调用 Promise构造函数产生一个对象有很多种方法，构造函数是看起来最面向对象的一种，而且原生Promise实现也是使用的构造函数，因此我也决定使用构造函数的方法。首先，先写一个大概的框架出来： 123456789// 众所周知, reject，用来改变promise的状态function Promise(executor) &#123; this.status = 'pending' this.value = void 0 // 为了方便把value和reason合并 const resolve = function() &#123;&#125; const reject = function() &#123;&#125; executor(resolve, reject)&#125; 很明显，这个构造函数还有很多问题们一个一个来看: resolve和reject并没有什么卵用 首先，用过promise的都知道,resolve和reject是用来改变promise的状态的： 1234567891011121314function Promise(executor) &#123; this.status = 'pending' this.value = void 0 // 为了方便把value和reason合并 const resolve = value =&gt; &#123; this.value = value this.status = 'resolved' &#125; const reject = reason =&gt; &#123; this.value = reason this.status = 'rejected' &#125; executor(resolve, reject)&#125; 然后，当resolve或者reject调用的时候，需要执行在then方法里传入的相应的函数（通知）。有没有觉得这个有点类似于事件（发布-订阅模式）呢？ 1234567891011121314151617181920212223242526function Promise(executor) &#123; this.status = 'pending' this.value = void 0 // 为了方便把value和reason合并 this.resolveListeners = [] this.rejectListeners = [] // 通知状态改变 const notify(target, val) =&gt; &#123; target === 'resolved' ? this.resolveListeners.forEach(cb =&gt; cb(val)) : this.rejectListeners.forEach(cb =&gt; cb(val)) &#125; const resolve = value =&gt; &#123; this.value = value this.status = 'resolved' notify('resolved', value) &#125; const reject = reason =&gt; &#123; this.value = reason this.status = 'rejected' notify('rejected', reason) &#125; executor(resolve, reject)&#125; status和value并没有做到一旦确定，无法更改。这里有两个问题，一是返回的对象暴露了status和value属性，并且可以随意赋值；二是如果在executor里多次调用resolve或者reject，会使value更改多次。第一个问题，如何实现只读属性： 12345678910111213141516171819202122232425262728293031323334353637383940function Promise(executor) &#123; if (typeof executor !== 'function') &#123; throw new Error('Promise executor must be fucntion') &#125; let status = 'pending' // 闭包形成私有属性 let value = void 0 ...... // 使用status代替this.value const resolve = val =&gt; &#123; value = val status = 'resolved' notify('resolved', val) &#125; const reject = reason =&gt; &#123; value = reason status = 'rejected' notify('rejected', reason) &#125; // 通过getter和setter设置只读属性 Object.defineProperty(this, 'status', &#123; get() &#123; return status &#125;, set() &#123; console.warn('status is read-only') &#125; &#125;) Object.defineProperty(this, 'value', &#123; get() &#123; return value &#125;, set() &#123; console.warn('value is read-only') &#125; &#125;) 第二个问题，避免多次调用resolve、reject时改变value，而且标准里(—3 it must not be called more than once)也有规定，then注册的回调只能执行一次。 123456const resolve = val =&gt; &#123; if (status !== 'pending') return // 避免多次运行 value = val status = 'resolved' notify('resolved', val)&#125; then注册的回调需要异步执行。 说到异步执行，对原生Promise有了解的同学都知道,then注册的回调在Micro-task中，并且调度策略是，Macro-task中执行一个任务，清空所有Micro-task的任务。简而言之，promise异步的优先级更高。 其实，标准只规定了promise回调需要异步执行，在一个“干净的”执行栈执行，并没有规定一定说要用micro-task，并且在低版本浏览器中，并没有micro-task队列。不过在各种promise的讨论中，由于原生Promise的实现，micro-task已经成成为了事实标准，而且promise回调在micro-task中也使得程序的行为更好预测。 在浏览器端，可以用MutationObserver实现Micro-task。本文利用setTimeout来简单实现异步。 1234567891011121314const resolve = val =&gt; &#123; if (val instanceof Promise) &#123; return val.then(resolve, reject) &#125; // 异步执行 setTimeout(() =&gt; &#123; if (status !== 'pending') return status = 'resolved' value = val notify('resolved', val) &#125;, 0)&#125; 最后，加上错误处理，就得到了一个完整的Promise构造函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Promise(executor) &#123; if (typeof executor !== 'function') &#123; throw new Error('Promise executor must be fucntion') &#125; let status = 'pending' let value = void 0 const notify = (target, val) =&gt; &#123; target === 'resolved' ? this.resolveListeners.forEach(cb =&gt; cb(val)) : this.rejectListeners.forEach(cb =&gt; cb(val)) &#125; const resolve = val =&gt; &#123; if (val instanceof Promise) &#123; return val.then(resolve, reject) &#125; setTimeout(() =&gt; &#123; if (status !== 'pending') return status = 'resolved' value = val notify('resolved', val) &#125;, 0) &#125; const reject = reason =&gt; &#123; setTimeout(() =&gt; &#123; if (status !== 'pending') return status = 'rejected' value = reason notify('rejected', reason) &#125;, 0) &#125; this.resolveListeners = [] this.rejectListeners = [] Object.defineProperty(this, 'status', &#123; get() &#123; return status &#125;, set() &#123; console.warn('status is read-only') &#125; &#125;) Object.defineProperty(this, 'value', &#123; get() &#123; return value &#125;, set() &#123; console.warn('value is read-only') &#125; &#125;) try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125; 总的来说，Promise构造函数其实只干了一件事：执行传入的executor，并构造了executor的两个参数 实现then方法首先需要确定的是，then方法是写在构造函数里还是写在原型里。写在构造函数了里有一个比较大的好处：可以像处理status和value一样，通过闭包让resolveListeners和rejectListeners成为私有属性，避免通过this.rejectListeners来改变它。写在构造函数里的缺点是，每一个promise对象都会有一个不同的then方法，这既浪费内存，又不合理。我的选择是写在原型里，为了保持和原生Promise有一样的结构和接口。 ok,还是先写一个大概的框架： 123456Promise.prototype.then = function (resCb, rejCb) &#123; this.resolveListeners.push(resCb) this.rejectListeners.push(rejCb) return new Promise()&#125; 随后，一步一步的完善它： then方法返回的promise需要根据resCb或rejCb的运行结果来确定状态。 123456789101112131415161718192021Promise.prototype.then = function (resCb, rejCb) &#123; return new Promise((res, rej) =&gt; &#123; this.resolveListeners.push((val) =&gt; &#123; try &#123; const x = resCb(val) res(x) // 以resCb的返回值为value来resolve &#125; catch (e) &#123; rej(e) // 如果出错，返回的promise以异常为reason来reject &#125; &#125;) this.rejectListeners.push((val) =&gt; &#123; try &#123; const x = rejCb(val) res(x) // 注意这里也是res而不是rej哦 &#125; catch (e) &#123; rej(e) // 如果出错，返回的promise以异常为reason来reject &#125; &#125;) &#125;)&#125; ps：众所周知，promise可以链式调用，说起链式调用，我的第一个想法就是返回this就可以了，但是then方法不可以简单的返回this，而要返回一个新的promise对象。因为promise的状态一旦确定就不能更改，而then方法返回的promise的状态需要根据then回调的运行结果来决定。 如果resCb/rejCb返回一个promiseA，then返回的promise需要跟随(adopt)promiseA，也就是说，需要保持和promiseA一样的status和value。 123456789101112131415161718192021222324252627this.resolveListeners.push((val) =&gt; &#123; try &#123; const x = resCb(val) if (x instanceof Promise) &#123; x.then(res, rej) // adopt promise x &#125; else &#123; res(x) &#125; &#125; catch (e) &#123; rej(e) &#125;&#125;)this.rejectListeners.push((val) =&gt; &#123; try &#123; const x = resCb(val) if (x instanceof Promise) &#123; x.then(res, rej) // adopt promise x &#125; else &#123; res(x) &#125; &#125; catch (e) &#123; rej(e) &#125;&#125;) 如果then的参数不是函数，需要忽略它，类似于这种情况： 123new Promise(rs =&gt; rs(5)) .then() .then(console.log) 其实就是把value和状态往后传递 123456789101112131415161718this.resolveListeners.push((val) =&gt; &#123; if (typeof resCb !== 'function') &#123; res(val) return &#125; try &#123; const x = resCb(val) if (x instanceof Promise) &#123; x.then(res, rej) // adopt promise x &#125; else &#123; res(x) &#125; &#125; catch (e) &#123; rej(e) &#125;&#125;) // rejectListeners也是相同的逻辑 如果调用then时, promise的状态已经确定，相应的回调直接运行 123// 注意这里需要异步if (status === 'resolved') setTimeout(() =&gt; resolveCb(value), 0)if (status === 'rejected') setTimeout(() =&gt; rejectCb(value), 0) 最后，就得到了一个完整的then方法，总结一下，then方法干了两件事，一是注册了回调，二是返回一个新的promise对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// resolveCb和rejectCb是相同的逻辑，封装成一个函数const thenCallBack = (cb, res, rej, target, val) =&gt; &#123; if (typeof cb !== 'function') &#123; target === 'resolve' ? res(val) : rej(val) return &#125; try &#123; const x = cb(val) if (x instanceof Promise) &#123; x.then(res, rej) // adopt promise x &#125; else &#123; res(x) &#125; &#125; catch (e) &#123; rej(e) &#125;&#125;Promise.prototype.then = function (resCb, rejCb) &#123; const status = this.status const value = this.value let thenPromise thenPromise = new Promise((res, rej) =&gt; &#123; /** * 这里不能使用bind来实现柯里画，规范里规定了: * --5: onFulfilled and onRejected must be called as functions * (i.e. with no this value)) */ const resolveCb = val =&gt; &#123; thenCallBack(resCb, res, rej, 'resolve', val) &#125; const rejectCb = val =&gt; &#123; thenCallBack(rejCb, res, rej, 'reject', val) &#125; if (status === 'pending') &#123; this.resolveListeners.push(resolveCb) this.rejectListeners.push(rejectCb) &#125; if (status === 'resolved') setTimeout(() =&gt; resolveCb(value), 0) if (status === 'rejected') setTimeout(() =&gt; rejectCb(value), 0) &#125;) return thenPromise&#125; 不同的Promise实现可以互相调用首先要明白的是什么叫互相调用，什么情况下会互相调用。之前实现then方法的时候，有一条规则是：如果then方法的回调返回一个promiseA。then返回的promise需要adopt这个promiseA，也就是说，需要处理这种情况： 1234567new MyPromise(rs =&gt; rs(5)) .then(val =&gt; &#123; return Promise.resolve(5) // 原生Promise &#125;) .then(val =&gt; &#123; return new Bluebird(r =&gt; r(5)) // Bluebird的promise &#125;) 关于这个，规范里定义了一个叫做The Promise Resolution Procedure的过程，我们需要做的就是把规范翻译一遍，并替代代码中判断promise的地方 123456789101112131415161718192021222324252627282930313233343536373839const resolveThenable = (promise, x, resolve, reject) =&gt; &#123; if (x === promise) &#123; return reject(new TypeError('chain call found')) &#125; if (x instanceof Promise) &#123; return x.then(v =&gt; &#123; resolveThenable(promise, v, resolve, reject) &#125;, reject) &#125; if (x === null || (typeof x !== 'object' &amp;&amp; typeof x !== 'function')) &#123; return resolve(x) &#125; let called = false try &#123; // 这里有一个有意思的技巧. // 如果then是一个getter，那么通过赋值可以保证getter只被触发一次，避免副作用 const then = x.then if (typeof then !== 'function') &#123; return resolve(x) &#125; then.call(x, v =&gt; &#123; if (called) return called = true resolveThenable(promise, v, resolve, reject) &#125;, r =&gt; &#123; if (called) return called = true reject(r) &#125;) &#125; catch (e) &#123; if (called) return reject(e) &#125;&#125; 到这里，一个符合标准的Promise就完成了，完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146function Promise(executor) &#123; if (typeof executor !== 'function') &#123; throw new Error('Promise executor must be fucntion') &#125; let status = 'pending' let value = void 0 const notify = (target, val) =&gt; &#123; target === 'resolved' ? this.resolveListeners.forEach(cb =&gt; cb(val)) : this.rejectListeners.forEach(cb =&gt; cb(val)) &#125; const resolve = val =&gt; &#123; if (val instanceof Promise) &#123; return val.then(resolve, reject) &#125; setTimeout(() =&gt; &#123; if (status !== 'pending') return status = 'resolved' value = val notify('resolved', val) &#125;, 0) &#125; const reject = reason =&gt; &#123; setTimeout(() =&gt; &#123; if (status !== 'pending') return status = 'rejected' value = reason notify('rejected', reason) &#125;, 0) &#125; this.resolveListeners = [] this.rejectListeners = [] Object.defineProperty(this, 'status', &#123; get() &#123; return status &#125;, set() &#123; console.warn('status is read-only') &#125; &#125;) Object.defineProperty(this, 'value', &#123; get() &#123; return value &#125;, set() &#123; console.warn('value is read-only') &#125; &#125;) try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;const thenCallBack = (cb, res, rej, target, promise, val) =&gt; &#123; if (typeof cb !== 'function') &#123; target === 'resolve' ? res(val) : rej(val) return &#125; try &#123; const x = cb(val) resolveThenable(promise, x, res, rej) &#125; catch (e) &#123; rej(e) &#125;&#125;const resolveThenable = (promise, x, resolve, reject) =&gt; &#123; if (x === promise) &#123; return reject(new TypeError('chain call found')) &#125; if (x instanceof Promise) &#123; return x.then(v =&gt; &#123; resolveThenable(promise, v, resolve, reject) &#125;, reject) &#125; if (x === null || (typeof x !== 'object' &amp;&amp; typeof x !== 'function')) &#123; return resolve(x) &#125; let called = false try &#123; // 这里有一个有意思的技巧 // 如果then是一个getter，那么通过赋值可以保证getter只被触发一次，避免副作用 const then = x.then if (typeof then !== 'function') &#123; return resolve(x) &#125; then.call(x, v =&gt; &#123; if (called) return called = true resolveThenable(promise, v, resolve, reject) &#125;, r =&gt; &#123; if (called) return called = true reject(r) &#125;) &#125; catch (e) &#123; if (called) return reject(e) &#125;&#125;Promise.prototype.then = function (resCb, rejCb) &#123; const status = this.status const value = this.value let thenPromise thenPromise = new Promise((res, rej) =&gt; &#123; const resolveCb = val =&gt; &#123; thenCallBack(resCb, res, rej, 'resolve', thenPromise, val) &#125; const rejectCb = val =&gt; &#123; thenCallBack(rejCb, res, rej, 'reject', thenPromise, val) &#125; if (status === 'pending') &#123; this.resolveListeners.push(resolveCb) this.rejectListeners.push(rejectCb) &#125; if (status === 'resolved') setTimeout(() =&gt; resolveCb(value), 0) if (status === 'rejected') setTimeout(() =&gt; rejectCb(value), 0) &#125;) return thenPromise&#125; 测试脚本 关于promise的一些零散知识 Promise.resolve就是本文所实现的resolveThenable，并不是简单的用来返回一个resolved状态的函数，它返回的promise对象的状态也并不一定是resolved。 promise.then(rs, rj)和promise.then(rs).catch(rj)是有区别的，区别在于当rs出错时，后一种方法可以进行错误处理。 感想与总结实现Promise的过程其实并没有我预想的那么难，所谓的Promise的原理我感觉就是类似于观察者模式，so，不要有畏难情绪，我上我也行^_^。","categories":[{"name":"article","slug":"article","permalink":"moruo.vip/categories/article/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"moruo.vip/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"moruo.vip/tags/promise/"}]}]}